package Server;

import enums.InformationType;
import javafx.fxml.Initializable;
import objects.*;

import java.io.IOException;
import java.io.Serializable;
import java.net.InetAddress;
import java.util.HashSet;

/**
 * Created by Josh on 8/15/2016.
 */

// Room is created from server with all InetAddresses as param
// When users are added to a room after room is created they will use addUser() and we need to append to addresses

/** ------------Author: Adam Goins-------------------------------------------------
 *
 * The Function of this class is to hold a HashSet of active @Class ChatUsers and send messages localized to only members in the room.
 * The Room Class holds a Hashset of @Class ChatUsers that reflects all participating members in the chatroom.
 * Messages are Filtered through the @Class ConnectionManager > @FinalClass RoomHandler > @FinalClass RoomHandler and relayed appropriately using the @Method sendMessage method.
 *
 */

public class Room implements Serializable {

    private int key;             // The room's unique ID
    private String title;        // Title of the Room.
    private String password;     // The password for a password protected room.
    private String description;
    private User owner;

    private boolean isPublic = false;
    private boolean isStatic = false;
    private boolean passwordProtected = false;


    public static HashSet<ChatUser> activeUsers = new HashSet<>(); // Global Array of all Active Users



    public Room(String title){
        this.title = title;
    }

    public Room(SerializableRoom room){
        this.key = room.getKey();
        this.title = room.getTitle();
        this.password = room.getPassword();
        this.description = room.getDescription();
        this.owner = room.getOwner();
        this.isPublic = room.isPublic();
        this.isStatic = room.isStatic();
        this.passwordProtected = room.isPasswordProtected();
    }


    /**
     *
     * @param key
     *       Sets the Unique Room Identifier (int) to whatever key was generated by the @FinalClass RoomHandlerHandler.KeyGenerator() Method.
     *
     * @param title
     *        Title of the Room to be displayed wherever the Developer desires on the User Interface
     *
     * NOTE: This Constructor is used for rooms that do not require password protection
     */

    public Room(int key, String title){
        this.key = key;
        this.title = title;
    }

    /**
     *
     * @param key
     *        Sets the Unique Room Identifier (int) to whatever key was generated by the @FinalClass RoomHandlerHandler.KeyGenerator() Method.
     *
     * @param title
     *        Title of the Room to be displayed wherever the Developer desires on the User Interface
     *
     * @param passwordProtected
     *        Boolean used to reflect that this instance of @FinalClass RoomHandler is Password Protected.
     *
     * @param password
     *        The @String Password required to access this instance of @FinalClass RoomHandler.
     *
     *
     * NOTE: This Constructor is used for the purpose of a Password Protected instance of a @FinalClass RoomHandler.
     */

    public Room(int key, String title, boolean passwordProtected, String password){

        this.key = key;
        this.title = title;
        this.passwordProtected = passwordProtected;
        this.password = password;

    }

    /**
     * @Method sendMessage receives a @Class Message parameter and writes it to every user in the @FinalClass RoomHandler.
     * @param message The @Class Message that was filtered through the @FinalClass ConnectionManager to reach this @FinalClass RoomHandler instance.
     *
     */
    public void sendMessage(Message message){


        activeUsers.forEach(i -> { // For each user in this room
            if(!(message.getUser().equals(i.getUser()))) { // if user is not the one who sent message
                try {
                    i.getOutput().writeObject(message); // Write to the Client's OutputStream the message received from the @FinalClass ConnectionManager
                    i.getOutput().flush(); // Flushes the stream to ensure all bytes were sent across.
                } catch (IOException e1) {
                    e1.printStackTrace();
                }
            }
        });
    }

    public void writeObject(Object object){

        if(object.getClass().equals(Message.class)){
            Message message = (Message) object;
            sendMessage(message);
        }

        else if(object.getClass().equals(Command.class)){
            Command command = (Command) object;
            sendMessage(command);
        }

        else if(object.getClass().equals(InformationMessage.class)){
            sendToAll(object);
        }

        else if(object.getClass().equals(HashSet.class)) {
            sendToAll(object);
        }

    }

    public SerializableRoom getSerializedVersion(){
        SerializableRoom room = new SerializableRoom();
        room.setKey(getKey());
        room.setTitle(getTitle());
        room.setPassword(getPassword());
        room.setDescription(getDescription());
        room.setOwner(getOwner());
        room.setPublic(isPublic());
        room.setStatic(isStatic());
        room.setPasswordProtected(isPasswordProtected());
        return room;
    }


    public void sendToAll(Object object){
        activeUsers.forEach(i -> { // For each user in this room
            try {
                i.getOutput().writeObject(object); // Write to the Client's OutputStream the message received from the @FinalClass ConnectionManager
                i.getOutput().flush();             // Flushes the stream to ensure all bytes were sent across.
            } catch (IOException e1) {
                e1.printStackTrace();
            }
        });
    }
    /**
     * @Method sendMessage receives a @Class Message parameter and writes it to every user in the @FinalClass RoomHandler.
     * @param command The @Class Command that was filtered through the @FinalClass ConnectionManager to reach this @FinalClass RoomHandler instance.
     *
     */
    public void sendMessage(Command command){


        activeUsers.forEach(i -> { // For each user in this room
            if(!(command.getUser().equals(i.getUser()))) { // if user is not the one who sent message
                try {
                    i.getOutput().writeObject(command); // Write to the Client's OutputStream the message received from the @FinalClass ConnectionManager
                    i.getOutput().flush(); // Flushes the stream to ensure all bytes were sent across.
                } catch (IOException e1) {
                    e1.printStackTrace();
                }
            }
        });
    }

    /**
     * @Method addUser is used to add a new instance of @Class ChatUser to the @HashSet activeUsers, joining them to this instance of @FinalClass RoomHandler
     *
     * @param user
     *        Instance of @Class ChatUser that has joined this instance of @FinalClass RoomHandler
     */

    public void addUser(ChatUser user){
        InformationMessage newUserMessage = new InformationMessage("User: [" + user.getUser().getAlias() + "] has Connected.", user.getUser(), key, InformationType.USER_JOINED);
        writeObject(newUserMessage);
        activeUsers.add(user); // Adds new user to room
        updateLists();

    }

    /**
     * @Method removeUser removes a user from the room.
     * Note: If there are no more users left in the room, the room closes itself and the instance destroyed.
     *
     * @param user
     *        The @Class ChatUser that will be removed from the @FinalClass RoomHandler
     */

    public void removeUser(ChatUser user){

        activeUsers.remove(user);



        if(activeUsers.size() == 0 && getKey() != 0){
            closeRoom(); // Closes this instance of Room
        }

        else {
            InformationMessage newUserMessage = new InformationMessage("User: [" + user.getUser().getAlias() + "] has Disconnected.", user.getUser(), key, InformationType.USER_LEFT);
            writeObject(newUserMessage);
            updateLists();
        }
    }

    public void closeRoom(){
        RoomHandler.removeRoom(this); // Removes this Instance from the @FinalClass RoomHandler
    }

    public int getKey() {
        return key;
    }

    public void setKey(int key){
        this.key = key;
    }

    private synchronized void updateLists() {
        HashSet<User> u = new HashSet<>();
        activeUsers.forEach(value -> {
            u.add(value.getUser());
            System.out.println(value.getUser().getAlias());
        });
        writeObject(u);
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public boolean isPublic() {
        return isPublic;
    }

    public void setPublic(boolean aPublic) {
        isPublic = aPublic;
    }

    public boolean isStatic() {
        return isStatic;
    }

    public void setStatic(boolean aStatic) {
        isStatic = aStatic;
    }

    public boolean isPasswordProtected() {
        return passwordProtected;
    }

    public void setPasswordProtected(boolean passwordProtected) {
        this.passwordProtected = passwordProtected;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public User getOwner() {
        return owner;
    }

    public void setOwner(User owner) {
        this.owner = owner;
    }
}
